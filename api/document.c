/* document.c generated by valac 0.20.1, the Vala compiler
 * generated from document.vala, do not modify */


#include <glib.h>
#include <glib-object.h>
#include "geanyapi.h"
#include <document.h>
#include <filetypes.h>
#include <gio/gio.h>
#include <utils.h>

#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
#define _g_free0(var) (var = (g_free (var), NULL))

struct _GeanyDocPrivate {
	struct GeanyDocument* doc;
	GeanyFileType* ft;
};


static gpointer geany_doc_parent_class = NULL;

#define GEANY_DOC_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), GEANY_TYPE_DOC, GeanyDocPrivate))
enum  {
	GEANY_DOC_DUMMY_PROPERTY,
	GEANY_DOC_IS_VALID,
	GEANY_DOC_DOC_PTR,
	GEANY_DOC_FILE_TYPE,
	GEANY_DOC_FILE,
	GEANY_DOC_DISPLAY_NAME,
	GEANY_DOC_HAS_BOM,
	GEANY_DOC_HAS_TAGS,
	GEANY_DOC_INDEX,
	GEANY_DOC_IS_READONLY,
	GEANY_DOC_IS_CHANGED,
	GEANY_DOC_ENCODING
};
GeanyDoc* geany_doc_new (struct GeanyDocument* gdoc);
GeanyDoc* geany_doc_construct (GType object_type, struct GeanyDocument* gdoc);
GeanyFileType* geany_file_type_new (struct GeanyFiletype* ftype);
GeanyFileType* geany_file_type_construct (GType object_type, struct GeanyFiletype* ftype);
gboolean geany_window_is_doc_valid (GeanyWindow* self, GeanyDoc* doc);
static void geany_doc_finalize (GObject* obj);
static void _vala_geany_doc_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec);
static void _vala_geany_doc_set_property (GObject * object, guint property_id, const GValue * value, GParamSpec * pspec);


GeanyDoc* geany_doc_construct (GType object_type, struct GeanyDocument* gdoc) {
	GeanyDoc * self = NULL;
	struct GeanyDocument* _tmp0_;
	struct GeanyDocument* _tmp3_;
	struct GeanyFiletype* _tmp4_;
	GeanyFileType* _tmp5_;
	self = (GeanyDoc*) g_object_new (object_type, NULL);
	_tmp0_ = gdoc;
	if (_tmp0_ == NULL) {
		struct GeanyDocument* _tmp1_ = NULL;
		_tmp1_ = document_get_current ();
		self->priv->doc = _tmp1_;
	} else {
		struct GeanyDocument* _tmp2_;
		_tmp2_ = gdoc;
		self->priv->doc = _tmp2_;
	}
	_tmp3_ = self->priv->doc;
	_tmp4_ = _tmp3_->file_type;
	_tmp5_ = geany_file_type_new (_tmp4_);
	_g_object_unref0 (self->priv->ft);
	self->priv->ft = _tmp5_;
	return self;
}


GeanyDoc* geany_doc_new (struct GeanyDocument* gdoc) {
	return geany_doc_construct (GEANY_TYPE_DOC, gdoc);
}


gboolean geany_doc_get_is_valid (GeanyDoc* self) {
	gboolean result;
	GeanyWindow* _tmp0_ = NULL;
	GeanyWindow* _tmp1_;
	gboolean _tmp2_ = FALSE;
	gboolean _tmp3_;
	g_return_val_if_fail (self != NULL, FALSE);
	_tmp0_ = geany_window_get_default ();
	_tmp1_ = _tmp0_;
	_tmp2_ = geany_window_is_doc_valid (_tmp1_, self);
	_tmp3_ = _tmp2_;
	_g_object_unref0 (_tmp1_);
	result = _tmp3_;
	return result;
}


struct GeanyDocument* geany_doc_get_doc_ptr (GeanyDoc* self) {
	struct GeanyDocument* result;
	struct GeanyDocument* _tmp0_;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->priv->doc;
	result = _tmp0_;
	return result;
}


GeanyFileType* geany_doc_get_file_type (GeanyDoc* self) {
	GeanyFileType* result;
	GeanyFileType* _tmp0_;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->priv->ft;
	result = _tmp0_;
	return result;
}


GFile* geany_doc_get_file (GeanyDoc* self) {
	GFile* result;
	struct GeanyDocument* _tmp0_;
	const gchar* _tmp1_;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->priv->doc;
	_tmp1_ = _tmp0_->real_path;
	if (_tmp1_ != NULL) {
		struct GeanyDocument* _tmp2_;
		const gchar* _tmp3_;
		GFile* _tmp4_ = NULL;
		_tmp2_ = self->priv->doc;
		_tmp3_ = _tmp2_->real_path;
		_tmp4_ = g_file_new_for_path (_tmp3_);
		result = _tmp4_;
		return result;
	} else {
		struct GeanyDocument* _tmp5_;
		const gchar* _tmp6_;
		gchar* _tmp7_ = NULL;
		gchar* _tmp8_;
		GFile* _tmp9_ = NULL;
		GFile* _tmp10_;
		_tmp5_ = self->priv->doc;
		_tmp6_ = _tmp5_->file_name;
		_tmp7_ = utils_get_locale_from_utf8 (_tmp6_);
		_tmp8_ = _tmp7_;
		_tmp9_ = g_file_new_for_path (_tmp8_);
		_tmp10_ = _tmp9_;
		_g_free0 (_tmp8_);
		result = _tmp10_;
		return result;
	}
}


gchar* geany_doc_get_display_name (GeanyDoc* self) {
	gchar* result;
	struct GeanyDocument* _tmp0_;
	gchar* _tmp1_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->priv->doc;
	_tmp1_ = document_get_basename_for_display (_tmp0_, -1);
	result = _tmp1_;
	return result;
}


gboolean geany_doc_get_has_bom (GeanyDoc* self) {
	gboolean result;
	struct GeanyDocument* _tmp0_;
	gboolean _tmp1_;
	g_return_val_if_fail (self != NULL, FALSE);
	_tmp0_ = self->priv->doc;
	_tmp1_ = _tmp0_->has_bom;
	result = _tmp1_;
	return result;
}


gboolean geany_doc_get_has_tags (GeanyDoc* self) {
	gboolean result;
	struct GeanyDocument* _tmp0_;
	gboolean _tmp1_;
	g_return_val_if_fail (self != NULL, FALSE);
	_tmp0_ = self->priv->doc;
	_tmp1_ = _tmp0_->has_tags;
	result = _tmp1_;
	return result;
}


gint geany_doc_get_index (GeanyDoc* self) {
	gint result;
	struct GeanyDocument* _tmp0_;
	gint _tmp1_;
	g_return_val_if_fail (self != NULL, 0);
	_tmp0_ = self->priv->doc;
	_tmp1_ = _tmp0_->index;
	result = _tmp1_;
	return result;
}


gboolean geany_doc_get_is_readonly (GeanyDoc* self) {
	gboolean result;
	struct GeanyDocument* _tmp0_;
	gboolean _tmp1_;
	g_return_val_if_fail (self != NULL, FALSE);
	_tmp0_ = self->priv->doc;
	_tmp1_ = _tmp0_->readonly;
	result = _tmp1_;
	return result;
}


gboolean geany_doc_get_is_changed (GeanyDoc* self) {
	gboolean result;
	struct GeanyDocument* _tmp0_;
	gboolean _tmp1_;
	g_return_val_if_fail (self != NULL, FALSE);
	_tmp0_ = self->priv->doc;
	_tmp1_ = _tmp0_->changed;
	result = _tmp1_;
	return result;
}


void geany_doc_set_is_changed (GeanyDoc* self, gboolean value) {
	struct GeanyDocument* _tmp0_;
	gboolean _tmp1_;
	g_return_if_fail (self != NULL);
	_tmp0_ = self->priv->doc;
	_tmp1_ = value;
	document_set_text_changed (_tmp0_, _tmp1_);
	g_object_notify ((GObject *) self, "is-changed");
}


const gchar* geany_doc_get_encoding (GeanyDoc* self) {
	const gchar* result;
	struct GeanyDocument* _tmp0_;
	const gchar* _tmp1_;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->priv->doc;
	_tmp1_ = _tmp0_->encoding;
	result = _tmp1_;
	return result;
}


void geany_doc_set_encoding (GeanyDoc* self, const gchar* value) {
	struct GeanyDocument* _tmp0_;
	const gchar* _tmp1_;
	g_return_if_fail (self != NULL);
	_tmp0_ = self->priv->doc;
	_tmp1_ = value;
	document_set_encoding (_tmp0_, _tmp1_);
	g_object_notify ((GObject *) self, "encoding");
}


static void geany_doc_class_init (GeanyDocClass * klass) {
	geany_doc_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (GeanyDocPrivate));
	G_OBJECT_CLASS (klass)->get_property = _vala_geany_doc_get_property;
	G_OBJECT_CLASS (klass)->set_property = _vala_geany_doc_set_property;
	G_OBJECT_CLASS (klass)->finalize = geany_doc_finalize;
	g_object_class_install_property (G_OBJECT_CLASS (klass), GEANY_DOC_IS_VALID, g_param_spec_boolean ("is-valid", "is-valid", "is-valid", FALSE, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), GEANY_DOC_DOC_PTR, g_param_spec_pointer ("doc-ptr", "doc-ptr", "doc-ptr", G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), GEANY_DOC_FILE_TYPE, g_param_spec_object ("file-type", "file-type", "file-type", GEANY_TYPE_FILE_TYPE, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), GEANY_DOC_FILE, g_param_spec_object ("file", "file", "file", G_TYPE_FILE, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), GEANY_DOC_DISPLAY_NAME, g_param_spec_string ("display-name", "display-name", "display-name", NULL, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), GEANY_DOC_HAS_BOM, g_param_spec_boolean ("has-bom", "has-bom", "has-bom", FALSE, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), GEANY_DOC_HAS_TAGS, g_param_spec_boolean ("has-tags", "has-tags", "has-tags", FALSE, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), GEANY_DOC_INDEX, g_param_spec_int ("index", "index", "index", G_MININT, G_MAXINT, 0, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), GEANY_DOC_IS_READONLY, g_param_spec_boolean ("is-readonly", "is-readonly", "is-readonly", FALSE, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), GEANY_DOC_IS_CHANGED, g_param_spec_boolean ("is-changed", "is-changed", "is-changed", FALSE, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), GEANY_DOC_ENCODING, g_param_spec_string ("encoding", "encoding", "encoding", NULL, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
	g_signal_new ("closed", GEANY_TYPE_DOC, G_SIGNAL_RUN_LAST, 0, NULL, NULL, g_cclosure_marshal_VOID__VOID, G_TYPE_NONE, 0);
	g_signal_new ("reloaded", GEANY_TYPE_DOC, G_SIGNAL_RUN_LAST, 0, NULL, NULL, g_cclosure_marshal_VOID__VOID, G_TYPE_NONE, 0);
	g_signal_new ("saved", GEANY_TYPE_DOC, G_SIGNAL_RUN_LAST, 0, NULL, NULL, g_cclosure_marshal_VOID__VOID, G_TYPE_NONE, 0);
	g_signal_new ("activated", GEANY_TYPE_DOC, G_SIGNAL_RUN_LAST, 0, NULL, NULL, g_cclosure_marshal_VOID__VOID, G_TYPE_NONE, 0);
	g_signal_new ("filetype_changed", GEANY_TYPE_DOC, G_SIGNAL_RUN_LAST, 0, NULL, NULL, g_cclosure_marshal_VOID__OBJECT, G_TYPE_NONE, 1, GEANY_TYPE_FILE_TYPE);
}


static void geany_doc_instance_init (GeanyDoc * self) {
	self->priv = GEANY_DOC_GET_PRIVATE (self);
}


static void geany_doc_finalize (GObject* obj) {
	GeanyDoc * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, GEANY_TYPE_DOC, GeanyDoc);
	_g_object_unref0 (self->priv->ft);
	G_OBJECT_CLASS (geany_doc_parent_class)->finalize (obj);
}


GType geany_doc_get_type (void) {
	static volatile gsize geany_doc_type_id__volatile = 0;
	if (g_once_init_enter (&geany_doc_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (GeanyDocClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) geany_doc_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (GeanyDoc), 0, (GInstanceInitFunc) geany_doc_instance_init, NULL };
		GType geany_doc_type_id;
		geany_doc_type_id = g_type_register_static (G_TYPE_OBJECT, "GeanyDoc", &g_define_type_info, 0);
		g_once_init_leave (&geany_doc_type_id__volatile, geany_doc_type_id);
	}
	return geany_doc_type_id__volatile;
}


static void _vala_geany_doc_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec) {
	GeanyDoc * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (object, GEANY_TYPE_DOC, GeanyDoc);
	switch (property_id) {
		case GEANY_DOC_IS_VALID:
		g_value_set_boolean (value, geany_doc_get_is_valid (self));
		break;
		case GEANY_DOC_DOC_PTR:
		g_value_set_pointer (value, geany_doc_get_doc_ptr (self));
		break;
		case GEANY_DOC_FILE_TYPE:
		g_value_set_object (value, geany_doc_get_file_type (self));
		break;
		case GEANY_DOC_FILE:
		g_value_take_object (value, geany_doc_get_file (self));
		break;
		case GEANY_DOC_DISPLAY_NAME:
		g_value_take_string (value, geany_doc_get_display_name (self));
		break;
		case GEANY_DOC_HAS_BOM:
		g_value_set_boolean (value, geany_doc_get_has_bom (self));
		break;
		case GEANY_DOC_HAS_TAGS:
		g_value_set_boolean (value, geany_doc_get_has_tags (self));
		break;
		case GEANY_DOC_INDEX:
		g_value_set_int (value, geany_doc_get_index (self));
		break;
		case GEANY_DOC_IS_READONLY:
		g_value_set_boolean (value, geany_doc_get_is_readonly (self));
		break;
		case GEANY_DOC_IS_CHANGED:
		g_value_set_boolean (value, geany_doc_get_is_changed (self));
		break;
		case GEANY_DOC_ENCODING:
		g_value_set_string (value, geany_doc_get_encoding (self));
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}


static void _vala_geany_doc_set_property (GObject * object, guint property_id, const GValue * value, GParamSpec * pspec) {
	GeanyDoc * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (object, GEANY_TYPE_DOC, GeanyDoc);
	switch (property_id) {
		case GEANY_DOC_IS_CHANGED:
		geany_doc_set_is_changed (self, g_value_get_boolean (value));
		break;
		case GEANY_DOC_ENCODING:
		geany_doc_set_encoding (self, g_value_get_string (value));
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}



