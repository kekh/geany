/* window.c generated by valac 0.20.1, the Vala compiler
 * generated from window.vala, do not modify */


#include <glib.h>
#include <glib-object.h>
#include "geanyapi.h"
#include <document.h>
#include <gtk/gtk.h>
#include <geanyobject.h>
#include <filetypes.h>
#include <ui_utils.h>

#define _g_hash_table_unref0(var) ((var == NULL) ? NULL : (var = (g_hash_table_unref (var), NULL)))
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
#define _g_list_free0(var) ((var == NULL) ? NULL : (var = (g_list_free (var), NULL)))

struct _GeanyWindowPrivate {
	GHashTable* docs;
	GtkWindow* win;
	GtkNotebook* nb;
};


static gpointer geany_window_parent_class = NULL;
static GeanyWindow* geany_window_inst;
static GeanyWindow* geany_window_inst = NULL;

#define GEANY_WINDOW_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), GEANY_TYPE_WINDOW, GeanyWindowPrivate))
enum  {
	GEANY_WINDOW_DUMMY_PROPERTY,
	GEANY_WINDOW_ACTIVE_DOCUMENT,
	GEANY_WINDOW_DOCUMENTS,
	GEANY_WINDOW_UNSAVED_DOCUMENTS,
	GEANY_WINDOW_WIN_PTR
};
static GeanyWindow* geany_window_new (void);
static GeanyWindow* geany_window_construct (GType object_type);
static GeanyDoc* geany_window_add_or_lookup (GeanyWindow* self, struct GeanyDocument* gdoc);
GeanyDoc* geany_doc_new (struct GeanyDocument* gdoc);
GeanyDoc* geany_doc_construct (GType object_type, struct GeanyDocument* gdoc);
static void geany_window_on_document_close (GeanyObject* obj, struct GeanyDocument* gdoc, GeanyWindow* self);
static void _geany_window_on_document_close_geany_internal_object_document_close (GeanyObject* _sender, struct GeanyDocument* doc, gpointer self);
static void geany_window_on_document_new (GeanyObject* obj, struct GeanyDocument* gdoc, GeanyWindow* self);
static void _geany_window_on_document_new_geany_internal_object_document_new (GeanyObject* _sender, struct GeanyDocument* doc, gpointer self);
static void geany_window_on_document_opened (GeanyObject* obj, struct GeanyDocument* gdoc, GeanyWindow* self);
static void _geany_window_on_document_opened_geany_internal_object_document_open (GeanyObject* _sender, struct GeanyDocument* doc, gpointer self);
static void geany_window_on_document_activated (GeanyObject* obj, struct GeanyDocument* gdoc, GeanyWindow* self);
static void _geany_window_on_document_activated_geany_internal_object_document_activate (GeanyObject* _sender, struct GeanyDocument* doc, gpointer self);
static void geany_window_on_document_filetype_set (GeanyObject* obj, struct GeanyDocument* gdoc, struct GeanyFiletype* old_ft, GeanyWindow* self);
static void _geany_window_on_document_filetype_set_geany_internal_object_document_filetype_set (GeanyObject* _sender, struct GeanyDocument* doc, struct GeanyFiletype* old_ft, gpointer self);
static void geany_window_on_document_reloaded (GeanyObject* obj, struct GeanyDocument* gdoc, GeanyWindow* self);
static void _geany_window_on_document_reloaded_geany_internal_object_document_reload (GeanyObject* _sender, struct GeanyDocument* doc, gpointer self);
static void geany_window_on_document_saved (GeanyObject* obj, struct GeanyDocument* gdoc, GeanyWindow* self);
static void _geany_window_on_document_saved_geany_internal_object_document_save (GeanyObject* _sender, struct GeanyDocument* doc, gpointer self);
gboolean geany_window_is_doc_valid (GeanyWindow* self, GeanyDoc* doc);
GeanyFileType* geany_file_type_manager_lookup_ft (GeanyFileTypeManager* self, struct GeanyFiletype* gft);
static void g_cclosure_user_marshal_VOID__OBJECT_OBJECT (GClosure * closure, GValue * return_value, guint n_param_values, const GValue * param_values, gpointer invocation_hint, gpointer marshal_data);
static GObject * geany_window_constructor (GType type, guint n_construct_properties, GObjectConstructParam * construct_properties);
static void _g_object_unref0_ (gpointer var);
static void geany_window_finalize (GObject* obj);
static void _vala_geany_window_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec);


static gpointer _g_object_ref0 (gpointer self) {
	return self ? g_object_ref (self) : NULL;
}


static void _geany_window_on_document_close_geany_internal_object_document_close (GeanyObject* _sender, struct GeanyDocument* doc, gpointer self) {
	geany_window_on_document_close (_sender, doc, self);
}


static void _geany_window_on_document_new_geany_internal_object_document_new (GeanyObject* _sender, struct GeanyDocument* doc, gpointer self) {
	geany_window_on_document_new (_sender, doc, self);
}


static void _geany_window_on_document_opened_geany_internal_object_document_open (GeanyObject* _sender, struct GeanyDocument* doc, gpointer self) {
	geany_window_on_document_opened (_sender, doc, self);
}


static void _geany_window_on_document_activated_geany_internal_object_document_activate (GeanyObject* _sender, struct GeanyDocument* doc, gpointer self) {
	geany_window_on_document_activated (_sender, doc, self);
}


static void _geany_window_on_document_filetype_set_geany_internal_object_document_filetype_set (GeanyObject* _sender, struct GeanyDocument* doc, struct GeanyFiletype* old_ft, gpointer self) {
	geany_window_on_document_filetype_set (_sender, doc, old_ft, self);
}


static void _geany_window_on_document_reloaded_geany_internal_object_document_reload (GeanyObject* _sender, struct GeanyDocument* doc, gpointer self) {
	geany_window_on_document_reloaded (_sender, doc, self);
}


static void _geany_window_on_document_saved_geany_internal_object_document_save (GeanyObject* _sender, struct GeanyDocument* doc, gpointer self) {
	geany_window_on_document_saved (_sender, doc, self);
}


static GeanyDoc* geany_window_add_or_lookup (GeanyWindow* self, struct GeanyDocument* gdoc) {
	GeanyDoc* result = NULL;
	GHashTable* _tmp0_;
	struct GeanyDocument* _tmp1_;
	gconstpointer _tmp2_ = NULL;
	GeanyDoc* doc;
	GeanyDoc* _tmp3_;
	struct GeanyDocument* _tmp5_;
	GeanyDoc* _tmp6_;
	GeanyDoc* new_doc;
	GHashTable* _tmp7_;
	struct GeanyDocument* _tmp8_;
	GeanyDoc* _tmp9_;
	GeanyDoc* _tmp10_;
	GeanyObject* _tmp11_ = NULL;
	GeanyObject* gobj;
	GeanyObject* _tmp12_;
	GeanyObject* _tmp13_;
	GeanyObject* _tmp14_;
	GeanyObject* _tmp15_;
	GeanyObject* _tmp16_;
	GeanyObject* _tmp17_;
	GeanyObject* _tmp18_;
	GHashTable* _tmp19_;
	struct GeanyDocument* _tmp20_;
	gconstpointer _tmp21_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	g_return_val_if_fail (gdoc != NULL, NULL);
	_tmp0_ = self->priv->docs;
	_tmp1_ = gdoc;
	_tmp2_ = g_hash_table_lookup (_tmp0_, _tmp1_);
	doc = (GeanyDoc*) _tmp2_;
	_tmp3_ = doc;
	if (_tmp3_ != NULL) {
		GeanyDoc* _tmp4_;
		_tmp4_ = doc;
		result = _tmp4_;
		return result;
	}
	_tmp5_ = gdoc;
	_tmp6_ = geany_doc_new (_tmp5_);
	new_doc = _tmp6_;
	_tmp7_ = self->priv->docs;
	_tmp8_ = gdoc;
	_tmp9_ = new_doc;
	_tmp10_ = _g_object_ref0 (_tmp9_);
	g_hash_table_insert (_tmp7_, _tmp8_, _tmp10_);
	_tmp11_ = geany_object_get_default ();
	gobj = _tmp11_;
	_tmp12_ = gobj;
	g_signal_connect_object (_tmp12_, "document-close", (GCallback) _geany_window_on_document_close_geany_internal_object_document_close, self, 0);
	_tmp13_ = gobj;
	g_signal_connect_object (_tmp13_, "document-new", (GCallback) _geany_window_on_document_new_geany_internal_object_document_new, self, 0);
	_tmp14_ = gobj;
	g_signal_connect_object (_tmp14_, "document-open", (GCallback) _geany_window_on_document_opened_geany_internal_object_document_open, self, 0);
	_tmp15_ = gobj;
	g_signal_connect_object (_tmp15_, "document-activate", (GCallback) _geany_window_on_document_activated_geany_internal_object_document_activate, self, 0);
	_tmp16_ = gobj;
	g_signal_connect_object (_tmp16_, "document-filetype-set", (GCallback) _geany_window_on_document_filetype_set_geany_internal_object_document_filetype_set, self, 0);
	_tmp17_ = gobj;
	g_signal_connect_object (_tmp17_, "document-reload", (GCallback) _geany_window_on_document_reloaded_geany_internal_object_document_reload, self, 0);
	_tmp18_ = gobj;
	g_signal_connect_object (_tmp18_, "document-save", (GCallback) _geany_window_on_document_saved_geany_internal_object_document_save, self, 0);
	_tmp19_ = self->priv->docs;
	_tmp20_ = gdoc;
	_tmp21_ = g_hash_table_lookup (_tmp19_, _tmp20_);
	result = (GeanyDoc*) _tmp21_;
	_g_object_unref0 (new_doc);
	return result;
}


gboolean geany_window_is_doc_valid (GeanyWindow* self, GeanyDoc* doc) {
	gboolean result = FALSE;
	GHashTable* _tmp0_;
	GeanyDoc* _tmp1_;
	struct GeanyDocument* _tmp2_;
	struct GeanyDocument* _tmp3_;
	gconstpointer _tmp4_ = NULL;
	g_return_val_if_fail (self != NULL, FALSE);
	g_return_val_if_fail (doc != NULL, FALSE);
	_tmp0_ = self->priv->docs;
	_tmp1_ = doc;
	_tmp2_ = geany_doc_get_doc_ptr (_tmp1_);
	_tmp3_ = _tmp2_;
	_tmp4_ = g_hash_table_lookup (_tmp0_, _tmp3_);
	result = ((GeanyDoc*) _tmp4_) != NULL;
	return result;
}


static void geany_window_on_document_close (GeanyObject* obj, struct GeanyDocument* gdoc, GeanyWindow* self) {
	struct GeanyDocument* _tmp0_;
	GeanyDoc* _tmp1_ = NULL;
	GeanyDoc* doc;
	GHashTable* _tmp2_;
	struct GeanyDocument* _tmp3_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (obj != NULL);
	g_return_if_fail (gdoc != NULL);
	_tmp0_ = gdoc;
	_tmp1_ = geany_window_add_or_lookup (self, _tmp0_);
	doc = _tmp1_;
	g_signal_emit_by_name (doc, "closed");
	g_signal_emit_by_name (self, "document-closed", doc);
	_tmp2_ = self->priv->docs;
	_tmp3_ = gdoc;
	g_hash_table_remove (_tmp2_, _tmp3_);
}


static void geany_window_on_document_new (GeanyObject* obj, struct GeanyDocument* gdoc, GeanyWindow* self) {
	struct GeanyDocument* _tmp0_;
	GeanyDoc* _tmp1_ = NULL;
	GeanyDoc* doc;
	g_return_if_fail (self != NULL);
	g_return_if_fail (obj != NULL);
	g_return_if_fail (gdoc != NULL);
	_tmp0_ = gdoc;
	_tmp1_ = geany_window_add_or_lookup (self, _tmp0_);
	doc = _tmp1_;
	g_signal_emit_by_name (self, "document-new", doc);
	g_signal_emit_by_name (self, "document-added", doc);
}


static void geany_window_on_document_opened (GeanyObject* obj, struct GeanyDocument* gdoc, GeanyWindow* self) {
	struct GeanyDocument* _tmp0_;
	GeanyDoc* _tmp1_ = NULL;
	GeanyDoc* doc;
	g_return_if_fail (self != NULL);
	g_return_if_fail (obj != NULL);
	g_return_if_fail (gdoc != NULL);
	_tmp0_ = gdoc;
	_tmp1_ = geany_window_add_or_lookup (self, _tmp0_);
	doc = _tmp1_;
	g_signal_emit_by_name (self, "document-opened", doc);
	g_signal_emit_by_name (self, "document-added", doc);
}


static void geany_window_on_document_activated (GeanyObject* obj, struct GeanyDocument* gdoc, GeanyWindow* self) {
	struct GeanyDocument* _tmp0_;
	GeanyDoc* _tmp1_ = NULL;
	GeanyDoc* doc;
	g_return_if_fail (self != NULL);
	g_return_if_fail (obj != NULL);
	g_return_if_fail (gdoc != NULL);
	_tmp0_ = gdoc;
	_tmp1_ = geany_window_add_or_lookup (self, _tmp0_);
	doc = _tmp1_;
	g_signal_emit_by_name (doc, "activated");
	g_signal_emit_by_name (self, "document-activated", doc);
}


static void geany_window_on_document_reloaded (GeanyObject* obj, struct GeanyDocument* gdoc, GeanyWindow* self) {
	struct GeanyDocument* _tmp0_;
	GeanyDoc* _tmp1_ = NULL;
	GeanyDoc* doc;
	g_return_if_fail (self != NULL);
	g_return_if_fail (obj != NULL);
	g_return_if_fail (gdoc != NULL);
	_tmp0_ = gdoc;
	_tmp1_ = geany_window_add_or_lookup (self, _tmp0_);
	doc = _tmp1_;
	g_signal_emit_by_name (doc, "reloaded");
	g_signal_emit_by_name (self, "document-reloaded", doc);
}


static void geany_window_on_document_saved (GeanyObject* obj, struct GeanyDocument* gdoc, GeanyWindow* self) {
	struct GeanyDocument* _tmp0_;
	GeanyDoc* _tmp1_ = NULL;
	GeanyDoc* doc;
	g_return_if_fail (self != NULL);
	g_return_if_fail (obj != NULL);
	g_return_if_fail (gdoc != NULL);
	_tmp0_ = gdoc;
	_tmp1_ = geany_window_add_or_lookup (self, _tmp0_);
	doc = _tmp1_;
	g_signal_emit_by_name (doc, "saved");
	g_signal_emit_by_name (self, "document-saved", doc);
}


static void geany_window_on_document_filetype_set (GeanyObject* obj, struct GeanyDocument* gdoc, struct GeanyFiletype* old_ft, GeanyWindow* self) {
	struct GeanyDocument* _tmp0_;
	GeanyDoc* _tmp1_ = NULL;
	GeanyDoc* doc;
	GeanyFileTypeManager* _tmp2_ = NULL;
	GeanyFileTypeManager* _tmp3_;
	struct GeanyFiletype* _tmp4_;
	GeanyFileType* _tmp5_ = NULL;
	GeanyFileType* _tmp6_;
	GeanyFileType* ft;
	g_return_if_fail (self != NULL);
	g_return_if_fail (obj != NULL);
	g_return_if_fail (gdoc != NULL);
	g_return_if_fail (old_ft != NULL);
	_tmp0_ = gdoc;
	_tmp1_ = geany_window_add_or_lookup (self, _tmp0_);
	doc = _tmp1_;
	_tmp2_ = geany_file_type_manager_get_default ();
	_tmp3_ = _tmp2_;
	_tmp4_ = old_ft;
	_tmp5_ = geany_file_type_manager_lookup_ft (_tmp3_, _tmp4_);
	_tmp6_ = _tmp5_;
	_g_object_unref0 (_tmp3_);
	ft = _tmp6_;
	g_signal_emit_by_name (doc, "filetype-changed", ft);
	g_signal_emit_by_name (self, "document-filetype-changed", doc, ft);
}


static GeanyWindow* geany_window_construct (GType object_type) {
	GeanyWindow * self = NULL;
	self = (GeanyWindow*) g_object_new (object_type, NULL);
	return self;
}


static GeanyWindow* geany_window_new (void) {
	return geany_window_construct (GEANY_TYPE_WINDOW);
}


GeanyWindow* geany_window_get_default (void) {
	GeanyWindow* result = NULL;
	GeanyWindow* _tmp0_;
	GeanyWindow* _tmp1_;
	_tmp0_ = geany_window_inst;
	_tmp1_ = _g_object_ref0 (_tmp0_);
	result = _tmp1_;
	return result;
}


GeanyDoc* geany_window_get_active_document (GeanyWindow* self) {
	GeanyDoc* result;
	struct GeanyDocument* _tmp0_ = NULL;
	GeanyDoc* _tmp1_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = document_get_current ();
	_tmp1_ = geany_window_add_or_lookup (self, _tmp0_);
	result = _tmp1_;
	return result;
}


GList* geany_window_get_documents (GeanyWindow* self) {
	GList* result;
	GHashTable* _tmp0_;
	GList* _tmp1_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->priv->docs;
	_tmp1_ = g_hash_table_get_values (_tmp0_);
	result = _tmp1_;
	return result;
}


GList* geany_window_get_unsaved_documents (GeanyWindow* self) {
	GList* result;
	GList* doc_list;
	GHashTable* _tmp0_;
	GList* _tmp1_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	doc_list = NULL;
	_tmp0_ = self->priv->docs;
	_tmp1_ = g_hash_table_get_values (_tmp0_);
	{
		GList* doc_collection = NULL;
		GList* doc_it = NULL;
		doc_collection = _tmp1_;
		for (doc_it = doc_collection; doc_it != NULL; doc_it = doc_it->next) {
			GeanyDoc* doc = NULL;
			doc = (GeanyDoc*) doc_it->data;
			{
				GeanyDoc* _tmp2_;
				gboolean _tmp3_;
				gboolean _tmp4_;
				_tmp2_ = doc;
				_tmp3_ = geany_doc_get_is_changed (_tmp2_);
				_tmp4_ = _tmp3_;
				if (_tmp4_) {
					GeanyDoc* _tmp5_;
					_tmp5_ = doc;
					doc_list = g_list_append (doc_list, _tmp5_);
				}
			}
		}
		_g_list_free0 (doc_collection);
	}
	result = doc_list;
	return result;
}


GtkWindow* geany_window_get_win_ptr (GeanyWindow* self) {
	GtkWindow* result;
	GtkWindow* _tmp0_;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->priv->win;
	result = _tmp0_;
	return result;
}


static void g_cclosure_user_marshal_VOID__OBJECT_OBJECT (GClosure * closure, GValue * return_value, guint n_param_values, const GValue * param_values, gpointer invocation_hint, gpointer marshal_data) {
	typedef void (*GMarshalFunc_VOID__OBJECT_OBJECT) (gpointer data1, gpointer arg_1, gpointer arg_2, gpointer data2);
	register GMarshalFunc_VOID__OBJECT_OBJECT callback;
	register GCClosure * cc;
	register gpointer data1;
	register gpointer data2;
	cc = (GCClosure *) closure;
	g_return_if_fail (n_param_values == 3);
	if (G_CCLOSURE_SWAP_DATA (closure)) {
		data1 = closure->data;
		data2 = param_values->data[0].v_pointer;
	} else {
		data1 = param_values->data[0].v_pointer;
		data2 = closure->data;
	}
	callback = (GMarshalFunc_VOID__OBJECT_OBJECT) (marshal_data ? marshal_data : cc->callback);
	callback (data1, g_value_get_object (param_values + 1), g_value_get_object (param_values + 2), data2);
}


static void _g_object_unref0_ (gpointer var) {
	(var == NULL) ? NULL : (var = (g_object_unref (var), NULL));
}


static GObject * geany_window_constructor (GType type, guint n_construct_properties, GObjectConstructParam * construct_properties) {
	GObject * obj;
	GObjectClass * parent_class;
	GeanyWindow * self;
	GHashFunc _tmp0_;
	GEqualFunc _tmp1_;
	GHashTable* _tmp2_;
	GObject* _tmp3_ = NULL;
	GtkWindow* _tmp4_;
	GObject* _tmp5_ = NULL;
	GtkNotebook* _tmp6_;
	parent_class = G_OBJECT_CLASS (geany_window_parent_class);
	obj = parent_class->constructor (type, n_construct_properties, construct_properties);
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, GEANY_TYPE_WINDOW, GeanyWindow);
	_tmp0_ = g_direct_hash;
	_tmp1_ = g_direct_equal;
	_tmp2_ = g_hash_table_new_full (_tmp0_, _tmp1_, NULL, _g_object_unref0_);
	_g_hash_table_unref0 (self->priv->docs);
	self->priv->docs = _tmp2_;
	_tmp3_ = ui_builder_get_object ("window1");
	_tmp4_ = G_TYPE_CHECK_INSTANCE_TYPE (_tmp3_, GTK_TYPE_WINDOW) ? ((GtkWindow*) _tmp3_) : NULL;
	if (_tmp4_ == NULL) {
		_g_object_unref0 (_tmp3_);
	}
	_g_object_unref0 (self->priv->win);
	self->priv->win = _tmp4_;
	_tmp5_ = ui_builder_get_object ("notebook1");
	_tmp6_ = G_TYPE_CHECK_INSTANCE_TYPE (_tmp5_, GTK_TYPE_NOTEBOOK) ? ((GtkNotebook*) _tmp5_) : NULL;
	if (_tmp6_ == NULL) {
		_g_object_unref0 (_tmp5_);
	}
	_g_object_unref0 (self->priv->nb);
	self->priv->nb = _tmp6_;
	return obj;
}


static void geany_window_class_init (GeanyWindowClass * klass) {
	GeanyWindow* _tmp0_;
	geany_window_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (GeanyWindowPrivate));
	G_OBJECT_CLASS (klass)->get_property = _vala_geany_window_get_property;
	G_OBJECT_CLASS (klass)->constructor = geany_window_constructor;
	G_OBJECT_CLASS (klass)->finalize = geany_window_finalize;
	g_object_class_install_property (G_OBJECT_CLASS (klass), GEANY_WINDOW_ACTIVE_DOCUMENT, g_param_spec_object ("active-document", "active-document", "active-document", GEANY_TYPE_DOC, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), GEANY_WINDOW_DOCUMENTS, g_param_spec_pointer ("documents", "documents", "documents", G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), GEANY_WINDOW_UNSAVED_DOCUMENTS, g_param_spec_pointer ("unsaved-documents", "unsaved-documents", "unsaved-documents", G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), GEANY_WINDOW_WIN_PTR, g_param_spec_object ("win-ptr", "win-ptr", "win-ptr", GTK_TYPE_WINDOW, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE));
	g_signal_new ("document_closed", GEANY_TYPE_WINDOW, G_SIGNAL_RUN_LAST, 0, NULL, NULL, g_cclosure_marshal_VOID__OBJECT, G_TYPE_NONE, 1, GEANY_TYPE_DOC);
	g_signal_new ("document_added", GEANY_TYPE_WINDOW, G_SIGNAL_RUN_LAST, 0, NULL, NULL, g_cclosure_marshal_VOID__OBJECT, G_TYPE_NONE, 1, GEANY_TYPE_DOC);
	g_signal_new ("document_opened", GEANY_TYPE_WINDOW, G_SIGNAL_RUN_LAST, 0, NULL, NULL, g_cclosure_marshal_VOID__OBJECT, G_TYPE_NONE, 1, GEANY_TYPE_DOC);
	g_signal_new ("document_new", GEANY_TYPE_WINDOW, G_SIGNAL_RUN_LAST, 0, NULL, NULL, g_cclosure_marshal_VOID__OBJECT, G_TYPE_NONE, 1, GEANY_TYPE_DOC);
	g_signal_new ("document_activated", GEANY_TYPE_WINDOW, G_SIGNAL_RUN_LAST, 0, NULL, NULL, g_cclosure_marshal_VOID__OBJECT, G_TYPE_NONE, 1, GEANY_TYPE_DOC);
	g_signal_new ("document_reloaded", GEANY_TYPE_WINDOW, G_SIGNAL_RUN_LAST, 0, NULL, NULL, g_cclosure_marshal_VOID__OBJECT, G_TYPE_NONE, 1, GEANY_TYPE_DOC);
	g_signal_new ("document_saved", GEANY_TYPE_WINDOW, G_SIGNAL_RUN_LAST, 0, NULL, NULL, g_cclosure_marshal_VOID__OBJECT, G_TYPE_NONE, 1, GEANY_TYPE_DOC);
	g_signal_new ("document_filetype_changed", GEANY_TYPE_WINDOW, G_SIGNAL_RUN_LAST, 0, NULL, NULL, g_cclosure_user_marshal_VOID__OBJECT_OBJECT, G_TYPE_NONE, 2, GEANY_TYPE_DOC, GEANY_TYPE_FILE_TYPE);
	_tmp0_ = geany_window_new ();
	geany_window_inst = _tmp0_;
}


static void geany_window_instance_init (GeanyWindow * self) {
	self->priv = GEANY_WINDOW_GET_PRIVATE (self);
}


static void geany_window_finalize (GObject* obj) {
	GeanyWindow * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, GEANY_TYPE_WINDOW, GeanyWindow);
	_g_hash_table_unref0 (self->priv->docs);
	_g_object_unref0 (self->priv->win);
	_g_object_unref0 (self->priv->nb);
	G_OBJECT_CLASS (geany_window_parent_class)->finalize (obj);
}


GType geany_window_get_type (void) {
	static volatile gsize geany_window_type_id__volatile = 0;
	if (g_once_init_enter (&geany_window_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (GeanyWindowClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) geany_window_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (GeanyWindow), 0, (GInstanceInitFunc) geany_window_instance_init, NULL };
		GType geany_window_type_id;
		geany_window_type_id = g_type_register_static (G_TYPE_OBJECT, "GeanyWindow", &g_define_type_info, 0);
		g_once_init_leave (&geany_window_type_id__volatile, geany_window_type_id);
	}
	return geany_window_type_id__volatile;
}


static void _vala_geany_window_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec) {
	GeanyWindow * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (object, GEANY_TYPE_WINDOW, GeanyWindow);
	switch (property_id) {
		case GEANY_WINDOW_ACTIVE_DOCUMENT:
		g_value_set_object (value, geany_window_get_active_document (self));
		break;
		case GEANY_WINDOW_DOCUMENTS:
		g_value_set_pointer (value, geany_window_get_documents (self));
		break;
		case GEANY_WINDOW_UNSAVED_DOCUMENTS:
		g_value_set_pointer (value, geany_window_get_unsaved_documents (self));
		break;
		case GEANY_WINDOW_WIN_PTR:
		g_value_set_object (value, geany_window_get_win_ptr (self));
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}



